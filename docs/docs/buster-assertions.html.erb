Assertions

        <dl>
          <dt>Version</dt>
          <dd>0.8.1 <span class="date">(2011-12-04)</span></dd>
          <dt>Module</dt>
          <dd><code>require("buster-assertions");</code></dd>
          <dt>In browsers</dt>
          <dd><code>buster.assertions;</code></dd>
        </dl>
        <p>
          A collection of assertions to be used with a unit testing framework.
          <strong>buster-assertions</strong> works well with any CommonJS
          compliant testing framework out of the box, and can easily be
          configured to work with most any testing framework.
        </p>
        <p>
          <strong>buster-assertions</strong> contains lots of assertions. We
          strongly believe that high-level assertions are essential in the
          interest of producing clear and intent-revealing tests, and they also
          give you to-the-point failure messages.
        </p>
        <h3>Assertions and refutations</h3>
        <p>
          Unlike most assertion libraries, <strong>buster-assertion</strong>
          does not have <code>assert.notXyz</code> assertions to refute some
          fact. Instead, it has <em>refutations</em>, heavily inspired by Ruby's
          <a href="http://bfts.rubyforge.org/minitest/">minitest</a>:
        </p>
        <pre><code>var assert = buster.assertions.assert;
var refute = buster.assertions.refute;

assert.equals(42, 42);
refute.equals(42, 43);</code></pre>
        <p>
          Refutations help express "assert not ..." style verification in a much
          clearer way. It also brings with it a nice consistency in that
          any <code>assert.xyz</code> always has a corresponding
          <code>refute.xyz</code> that does the opposite check.
        </p>
        <h3>Custom assertions</h3>
        <p>
          Custom, domain-specific assertions helps improve clarity and reveal
          intent in tests. They also facilitate much better feedback when they
          fail. You can add custom assertions that behave exactly like the
          built-in ones (i.e. with counting, message formatting, expectations
          and more) by using the <%= anchor("add", "<code>add</code>") %>
          method.
        </p>
        <h3>Overriding assertion messages</h3>
        <p>
          The default assertion messages can be overridden. The properties to
          overwrite are listed with each assertion along with the arguments the
          string is fed. Here's an example of providing a new assertion failure
          message for <%= anchor("<code>assert.equals</code>", "assert-equals") %>:
        </p>
        <pre><code>var assert = buster.assertions.assert;
assert.equals.message = "I wanted ${0} == ${1}!"

try {
    assert.equals(3, 4);
} catch (e) {
    console.log(e.message);
}

// Prints:
// "I wanted 3 == 4!"</code></pre>
        <div class="section">
          <h2 id="<%= id('events') %>">Events</h2>
          <div class="intro">
            <p>
              <code>buster.assertions</code> is an <%= m("eventEmitter") %>. Listen to
              events with <code>on</code>:
            </p>
            <pre><code>buster.assertions.on("failure", function (err) {
    console.log(err.message);
});</code></pre>
          </div>
          <%= event("pass") %>
          <p>
            Assertion passed. The callback is invoked with the assertion name,
            e.g. <code>"equals"</code>, as its only argument. Note that this
            event is also emitted when refutations pass.
          </p>
          <%= event("failure", [[:error, "#AssertionError"]]) %>
          <p>
            Assertion failed. The callback is invoked with an
            <%=l "AssertionError" %> object.
          </p>
        </div>
        <div class="section">
          <h2 id="<%= id('assertions') %>">Assertions</h2>
          <p>
            Examples assume that you have
            aliased <code>buster.assertions.assert</code> as such:
          </p>
          <pre><code>var assert = buster.assertions.assert;</code></pre>
          <h3 id="<%= id('assert') %>" data-title="+assert(actual[, msg])+"><code>assert(actual[, message]);</code></h3>
          <p>
            Fails if <code>actual</code> is falsy
            (<code>0</code>, <code>""</code>, <code>null</code>, <code>undefined</code>,
            <code>NaN</code>). Fails with either the provided message or "Expected
            null to be truthy". This behavior differs from all other assertions,
            which does not allow for the optional message argument.
          </p>
          <pre><code>assert({ not: "Falsy" }, "This will pass");
assert(null, "This will fail"); // Fails with custom message
assert(null); // Fails
assert(34);   // Passes
</code></pre>
          <h3 id="<%= id('assert-same') %>" data-title="+same(expected, actual)+"><code>assert.same(expected, actual)</code></h3>
          <p>
            Fails if <code>actual</code> <strong>is not</strong> the same object
            (<code>===</code>) as <code>expected</code>. To compare similar
            objects, such as <code>{ name: "Chris", id: 42 }</code> and <code>{
              id: 42, name: "Chris" }</code> (not the same instance), see
            <%=l "assert.equals" %>. The optional message is prepended
            to the failure message if provided.
          </p>
          <pre><code>var obj = { id: 42, name: "Chris" };

assert.same(obj, obj);                       // Passes
assert.same(obj, { id: 42, name: "Chris" }); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.same.message = "${0} expected to be the same object as ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 id="<%= id('assert-equals') %>" data-title="+equals(actual, expected)+"><code>assert.equals(actual, expected)</code></h3>
          <p>
            Compares <code>actual</code> to <code>expected</code> property by
            property. If the property count does not match, or if any
            of <code>actual</code>'s properties does not match the corresponding
            property in <code>expected</code>, the assertion fails. Object
            properties are verified recursively.
          </p>
          <p>
            If <code>actual</code> is <code>null</code>
            or <code>undefined</code>, an exact match is required. Date objects
            are compared by their <code>getTime</code> method. Regular
            expressions are compared by their string representations. Primitives
            are compared using <code>==</code>, i.e., with coercion.
          </p>
          <p>
            <code>equals</code> passes when comparing an <code>arguments</code>
            object to an array if the both contain the same elements.
          </p>
          <pre><code>var assert = assert;
assert.equals({ name: "Professor Chaos" }, { name: "Professor Chaos" }); // Passes
assert.equals({ name: "Professor Chaos" }, { name: "Dr Evil" });         // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.equals.message = "${0} expected to be equal to ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+typeOf(object, expected)+"
              id="<%= id('assert-typeOf') %>"><code>assert.typeOf(object, expected)</code></h3>
          <p>
            Fails if <code>typeof object</code> is not <code>expected</code>.
            The optional message is prepended to the failure message if
            provided.
          </p>
          <pre><code>assert.typeOf({}, "object", "This will pass");
assert.typeOf({}, "object");     // Passes
assert.typeOf(null, "function"); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.typeOf.message = "typeof ${0} (${2}) expected to be ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected type, a string</dd>
              <dt><code>${2}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+defined(object)+"
              id="<%= id('assert-defined') %>"><code>assert.defined(object)</code></h3>
          <p>
            Fails if <code>object</code> is <code>undefined</code>. The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var a;
assert.defined({});  // Passes
assert.defined(a); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.defined.message = "Expected to be defined";</code></p>
          </div>
          <h3 data-title="+isNull(object)+" id="<%= id('assert-isNull') %>"><code>assert.isNull(object)</code></h3>
          <p>
            Fails if <code>object</code> is not <code>null</code>. The optional
            message is prepended to the failure message if provided.
          </p>
          <pre><code>assert.isNull(null, "This will pass");
assert.isNull({}, "This will fail");
assert.isNull(null); // Passes
assert.isNull({});   // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.isNull.message = "Expected ${0} to be null";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
            </dl>
          </div>
          <h3 data-title="+match(actual, matcher)+"
              id="<%= id('assert-match') %>"><code>assert.match(actual, matcher)</code></h3>
          <p>
            Fails if <code>matcher</code> is not a partial match
            for <code>actual</code>. Accepts a wide range of input combinations.
            Note that <code>assert.match</code> is not symmetric - in some
            cases <code>assert.match(a, b)</code> may pass
            while <code>assert.match(b, a)</code> fails.
          </p>
          <h4>String matcher</h4>
          <p>
            In its simplest form, <code>assert.match</code> performs a case
            insensitive substring match. When the matcher is a string,
            the <code>actual</code> object is converted to a string, and the
            assertion passes if <code>actual</code> is a case-insensitive
            substring of <code>expected</code> as a string.
          </p>
          <pre><code>assert.match("Give me something", "Give");                           // Passes
assert.match("Give me something", "sumptn");                         // Fails
assert.match({ toString: function () { return "yeah"; } }, "Yeah!"); // Passes</code></pre>
          <p>
            The last example is not symmetric. When the matcher is a string, the
            actual value is coerced to a string - in this case
            using <code>toString</code>. Changing the order of the arguments
            would cause the matcher to be an object, in which case different
            rules apply (see below).
          </p>
          <h4>Boolean matcher</h4>
          <p>
            Performs a strict (i.e. <code>===</code>) match with the object. So,
            only <code>true</code> matches <code>true</code>, and only
            <code>false</code> matches <code>false</code>.
          </p>
          <h4>Regular expression matcher</h4>
          <p>
            When the matcher is a regular expression, the assertion will pass if
            <code>expected.test(actual)</code> is true. <code>assert.match</code>
            is written in a generic way, so any object with a <code>test</code>
            method will be used as a matcher this way.
          </p>
          <pre><code>assert.match("Give me something", /^[a-z\s]$/i); // Passes
assert.match("Give me something", /[0-9]/); // Fails
assert.match({ toString: function () { return "yeah!"; } }, /yeah/); // Passes
assert.match(234, /[a-z]/); // Fails</code></pre>
          <h4>Number matcher</h4>
          <p>
            When the matcher is a number, the assertion will pass if <code>matcher
              == actual</code>.
          </p>
          <pre><code>assert.match("123", 123); // Passes
assert.match("Give me something", 425); // Fails
assert.match({ toString: function () { return "42"; } }, 42); // Passes
assert.match(234, 1234); // Fails</code></pre>
          <h4>Function matcher</h4>
          <p>
            When the matcher is a function, it is called with <code>actual</code>
            as its only argument. The assertion will pass if the function
            returns <code>true</code>. A strict match is performed against the
            return value, so a boolean <code>true</code> is required, truthy is
            not enough.
          </p>
          <pre><code>// Passes
assert.match("123", function (exp) {
    return exp == "123";
});

// Fails
assert.match("Give me something", function () {
    return "ok";
});

// Passes
assert.match({
    toString: function () {
        return "42";
    }
}, function () { return true; });

// Fails
assert.match(234, function () {});</code></pre>
          <h4>Object matcher</h4>
          <p>
            As mentioned above, if an object matcher defines a <code>test</code>
            method the assertion will pass if <code>matcher.test(actual)</code>
            returns truthy. If the object does not have a <code>test</code>
            method, a recursive match is performed. If all properties
            of <code>matcher</code> matches corresponding properties
            in <code>actual</code>, the assertion passes. Note that the object
            matcher does not care if the number of properties in the two objects
            are the same - only if all properties in the matcher recursively
            "matches" ones in the actual object.
          </p>
          <pre><code>// Passes
assert.match("123", {
    test: function (arg) {
        return arg == 123;
    }
});

// Fails
assert.match({}, { prop: 42 });

// Passes
assert.match({
    name: "Chris",
    profession: "Programmer"
}, {
    name: "Chris"
});

// Fails
assert.match(234, {
    name: "Chris"
});</code></pre>
          <h4>DOM elements</h4>
          <p>
            <code>assert.match</code> can be very helpful when asserting on DOM
            elements, because it allows you to compare several properties with
            one assertion:
          </p>
          <pre><code>var el = document.getElementById("myEl");

assert.match(el, {
    tagName: "h2",
    className: "item",
    innerHTML: "Howdy"
});</code></pre>
          <div class="msg">
            <h4>Messages</h4>
            <p><code>assert.match.exceptionMessage = "${0}";</code></p>
            <p>
              Used when the matcher function throws an exception. This happens if
              the matcher is not any of the accepted types, for instance, a boolean.
            </p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>
                Message from exception thrown by matcher function.
              </dd>
            </dl>
            <p><code>assert.match.message = "${0} expected to match ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+isObject(object)+" id="<%= id('assert-isObject') %>"><code>assert.isObject(object)</code></h3>
          <p>
            Fails if <code>object</code> is not an object or if it
            is <code>null</code>.
          </p>
          <pre><code>assert.isObject({});             // Passes
assert.isObject(42);             // Fails
assert.isObject([1, 2, 3]);      // Passes
assert.isObject(function () {}); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.isObject.message = "${0} (${1}) expected to be object and not null";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+isFunction(object)+" id="<%= id('assert-isFunction') %>"><code>assert.isFunction(actual)</code></h3>
          <p>
            Fails if <code>actual</code> is not a function.
          </p>
          <pre><code>assert.isFunction({});             // Fails
assert.isFunction(42);             // Fails
assert.isFunction(function () {}); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.isFunction.message = "${0} (${1}) expected to be function";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual value</dd>
              <dt><code>${1}</code></dt>
              <dd><code>typeof actual value</code></dd>
            </dl>
          </div>
          <h3 data-title="+exception(callback[, type])+"
              id="<%= id('assert-exception') %>"><code>assert.exception(callback[, type])</code></h3>
          <p>
            Fails if <code>callback</code> does not throw an exception. If the
            optional <code>type</code> is provided, the assertion fails if the
            callback either does not throw an exception, <strong>or</strong> if
            the exception is not of the given type (determined by its
            <code>name</code> property).  The optional message is prepended to the
            failure message if provided.
          </p>
          <pre><code>// Passes
assert.exception(function () {
    throw new Error("Ooops!");
});

// Fails
assert.exception(function () {});

// Passes
assert.exception(function () {
    throw new TypeError("Ooops!");
}, "TypeError");

// Fails, wrong exception type
assert.exception(function () {
    throw new Error("Aww");
}, "TypeError");

// Fails
assert.exception(function () {}, "TypeError");</code></pre>
          <div class="msg">
            <h4>Messages</h4>
            <p>
              <code>assert.exception.typeNoExceptionMessage = "Expected ${0} but no exception was thrown";</code><br>
              <code>assert.exception.message = "Expected exception";</code><br>
              <code>assert.exception.typeFailMessage = "Expected ${0} but threw ${1}, (${2})";</code>
            </p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The expected exception type (if provided)</dd>
              <dt><code>${1}</code></dt>
              <dd>The type of exception thrown (if any)</dd>
              <dt><code>${2}</code></dt>
              <dd>The exception message</dd>
            </dl>
          </div>
          <h3 data-title="+tagName(element, tagName)+"
              id="<%= id('assert-tagName') %>"><code>assert.tagName(element, tagName)</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>tagName</code> property, or if its value is not a
            case-insensitive match with the expected <code>tagName</code>. The
            optional message is prepended to the failure message if provided.
            Works with any object.
          </p>
          <pre><code>assert.tagName(document.createElement("p"), "p"); // Passes
assert.tagName(document.createElement("h2"), "H2"); // Passes
assert.tagName(document.createElement("p"), "li");  // Fails</code></pre>
          <div class="msg">
            <h4>Messages</h4>
            <p><code>assert.tagName.noTagNameMessage = "Expected ${1} to have tagName property";</code></p>
            <p><code>assert.tagName.message = "Expected tagName to be ${0} but was ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The expected <code>tagName</code></dd>
              <dt><code>${1}</code></dt>
              <dd>
                If the object does not have a <code>tagName</code> property, this is
                the object. Otherwise, it is the value
                of <code>object.tagName</code>.
              </dd>
            </dl>
          </div>
          <h3 data-title="+className(element, tagName)+"
              id="<%= id('assert-className') %>"><code>assert.className(element, className)</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>className</code> property, or if its value is not a
            space-separated list of all class names in <code>classNames</code>.
          </p>
          <p>
            <code>classNames</code> can be either a space-delimited string or an
            array of class names. Every class specified by
            <code>classNames</code> must be found in the object's
            <code>className</code> property for the assertion to pass, but order
            does not matter.
          </p>
          <pre><code>var el = document.createElement("p");
el.className = "feed item blog-post";

assert.className(el, "item");           // Passes
assert.className(el, "news");           // Fails
assert.className(el, "blog-post feed"); // Passes
assert.className(el, "feed items");     // Fails, "items" is not a match
assert.className(el, ["item", "feed"]); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.className.noClassNameMessage = "Expected object to have className property";</code></p>
            <p><code>assert.className.message = "Expected object's className to include ${0} but was ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The expected <code>classNames</code></dd>
              <dt><code>${1}</code></dt>
              <dd>The value of the object's <code>className</code> property, if any.</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('stubs') %>">Stubs and spies</h2>
          <p>
            The default Buster.JS bundle comes with built-in spies, stubs and
            mocks provided by <a href="http://sinonjs.org">Sinon.JS</a>. The
            assertions are indisposable when working with spies and
            stubs. However, note that these assertions are technically provided
            by the integration package <%=m "sinon" %>, <em>not</em>
            <strong>buster-assertions</strong>. This only matters if you use
            this package stand-alone.
          </p>
          <h3 data-title="+called(spy)+"
              id="<%= id('assert-called') %>"><code>assert.called(spy)</code></h3>
          <p>
            Fails if the spy has never been called.
          </p>
          <pre><code>var spy = sinon.spy();

assert.called(spy); // Fails

spy();
assert.called(spy); // Passes

spy();
assert.called(spy); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.called.message = "Expected ${0} to be called at least once but was never called";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
            </dl>
          </div>
          <h3 data-title="+callOrder(spy, spy2, ...)+"
              id="<%= id('assert-callOrder') %>"><code>assert.callOrder(spy, spy2, ...)</code></h3>
          <p>
            Fails if the spies were not called in the specified order.
          </p>
          <pre><code>var spy1 = sinon.spy();
var spy2 = sinon.spy();
var spy3 = sinon.spy();

spy1();
spy2();
spy3();

assert.callOrder(spy1, spy3, spy2); // Fails
assert.callOrder(spy1, spy2, spy3); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.callOrder.message = "Expected ${expected} to be called in order but were called as ${actual}";</code></p>
            <dl>
              <dt><code>${expected}</code></dt>
              <dd>A string representation of the expected call order</dd>
              <dt><code>${actual}</code></dt>
              <dd>A string representation of the actual call order</dd>
            </dl>
          </div>
          <h3 data-title="+calledOnce(spy)+"
              id="<%= id('assert-calledOnce') %>"><code>assert.calledOnce(spy)</code></h3>
          <p>
            Fails if the spy has never been called or if it was called more than
            once.
          </p>
          <pre><code>var spy = sinon.spy();

assert.called(spy); // Fails

spy();
assert.called(spy); // Passes

spy();
assert.called(spy); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.calledOnce.message = "Expected ${0} to be called once but was called ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls, as a string. Ex: "two times"</dd>
              <dt><code>${2}</code></dt>
              <dd>
                The call log. All calls as a string. Each line is one call and
                includes passed arguments, returned value and more.
              </dd>
            </dl>
          </div>
          <h3 data-title="+calledTwice(spy)+"
              id="<%= id('assert-calledTwice') %>"><code>assert.calledTwice(spy)</code></h3>
          <p>
            Only passes if the spy was called exactly two times.
          </p>
          <pre><code>var spy = sinon.spy();

assert.called(spy); // Fails

spy();
assert.called(spy); // Fails

spy();
assert.called(spy); // Passes

spy();
assert.called(spy); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.calledTwice.message = "Expected ${0} to be called twice but was called ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls, as a string. Ex: "two times"</dd>
              <dt><code>${2}</code></dt>
              <dd>
                The call log. All calls as a string. Each line is one call and
                includes passed arguments, returned value and more.
              </dd>
            </dl>
          </div>
          <h3 data-title="+calledThrice(spy)+"
              id="<%= id('assert-calledThrice') %>"><code>assert.calledThrice(spy)</code></h3>
          <p>
            Only passes if the spy has been called exactly three times.
          </p>
          <pre><code>var spy = sinon.spy();

assert.called(spy); // Fails

spy();
assert.called(spy); // Fails

spy();
assert.called(spy); // Passes

spy();
assert.called(spy); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.calledThrice.message = "Expected ${0} to be called thrice but was called ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls, as a string. Ex: "two times"</dd>
              <dt><code>${2}</code></dt>
              <dd>
                The call log. All calls as a string. Each line is one call and
                includes passed arguments, returned value and more.
              </dd>
            </dl>
          </div>
          <h3 data-title="+calledWith(spy, arg1, arg2, ...)+"
              id="<%= id('assert-calledWith') %>"><code>assert.calledWith(spy, arg1, arg2, ...)</code></h3>
          <p>
            Passes if the spy was called at least once with the specified
            arguments. Other arguments may have been passed after the specified
            ones.
          </p>
          <pre><code>var spy = sinon.spy();
var arr = [1, 2, 3];
spy(12);
spy(42, 13);
spy("Hey", arr, 2);

assert.calledWith(spy, 12);         // Passes
assert.calledWith(spy, "Hey");      // Passes
assert.calledWith(spy, "Hey", 12);  // Fails
assert.calledWith(spy, "Hey", arr); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.calledWith.message = "Expected ${0} to be called with arguments ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected arguments</dd>
              <dt><code>${2}</code></dt>
              <dd>String representation of all calls.</dd>
            </dl>
          </div>
          <h3 data-title="+calledOnceWith(spy, arg1, arg2, ...)+"
              id="<%= id('assert-calledOnceWith') %>"><code>assert.calledOnceWith(spy, arg1, arg2, ...)</code></h3>
          <p>
            Passes if the spy was called exactly once and with the specified
            arguments. Other arguments may have been passed after the specified
            ones.
          </p>
          <pre><code>var spy = sinon.spy();
var arr = [1, 2, 3];
spy(12);

assert.calledOnceWith(spy, 12);     // Passes
assert.calledOnceWith(spy, 42);     // Fails

spy(42, 13);
assert.calledOnceWith(spy, 42, 13); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>assert.calledOnceWith.message = "Expected ${0} to be called once with arguments ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected arguments</dd>
              <dt><code>${2}</code></dt>
              <dd>String representation of all calls.</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('refutations') %>">Refutations</h2>
          <p>
            Examples assume that you have
            aliased <code>buster.assertions.refute</code> as such:
          </p>
          <pre><code>var refute = buster.assertions.refute;</code></pre>
          <h3 id="<%= id('refute') %>" data-title="+refute(actual[, msg])+"><code>refute(actual[, message]);</code></h3>
          <p>
            Fails if <code>actual</code> is truthy. Fails with either the
            provided message or "Expected null to be falsy". This behavior
            differs from all other refutations, which do not allow for the
            optional message argument.
          </p>
          <pre><code>refute({ not: "Falsy" }, "This will fail"); // Fails with custom message
refute(null, "This will pass");
refute(null); // Passes
refute(34);   // Fails
</code></pre>
          <h3 id="<%= id('refute-same') %>" data-title="+same(expected, actual)+"><code>refute.same(expected, actual)</code></h3>
          <p>
            Fails if <code>actual</code> <strong>is</strong> the same object
            (<code>===</code>) as <code>expected</code>. To compare similar
            objects, such as <code>{ name: "Chris", id: 42 }</code> and <code>{
            id: 42, name: "Chris" }</code> (not the same instance), see
            <%=l "refute.equals" %>. The optional message is prepended to the
            failure message if provided.
          </p>
          <pre><code>var obj = { id: 42, name: "Chris" };
refute.same(obj, { id: 42, name: "Chris" }); // Passes
refute.same(obj, obj);                       // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.same.message = "${0} expected not to be the same object as ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 id="<%= id('refute-equals') %>" data-title="+equals(actual, expected)+"><code>refute.equals(actual, expected)</code></h3>
          <p>
            Passes in any case where <%=l "assert.equals" %> fails.
            The optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var assert = assert;
refute.equals({ name: "Professor Chaos" }, { name: "Dr Evil" });        // Passes
refute.equals({ name: "Professor Chaos" }, { name: "Professor Chaos" });// Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.equals.message = "${0} expected not to be equal to ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+typeOf(object, expected)+"
              id="<%= id('refute-typeOf') %>"><code>refute.typeOf(object, expected)</code></h3>
          <p>
            Fails if <code>typeof object</code> is <code>expected</code>. The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.typeOf(null, "function"); // Passes
refute.typeOf({}, "object");     // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.typeOf.message = "typeof ${0} expected not to be ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected type, a string</dd>
            </dl>
          </div>
          <h3 data-title="+defined(object)+"
              id="<%= id('refute-defined') %>"><code>refute.defined(object)</code></h3>
          <p>
            Fails if <code>object</code> is not <code>undefined</code>. The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>var a;

refute.defined(undefined); // Passes
refute.defined({});        // Fails
refute.defined(a);         // Passes
refute.defined({});        // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.defined.message = "typeof ${0} (${1}) expected to be undefined";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+isNull(object)+"
              id="<%= id('refute-isNull') %>"><code>refute.isNull(object)</code></h3>
          <p>
            Fails if <code>object</code> is <code>null</code>. The optional
            message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.isNull({});   // Passes
refute.isNull(null); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.isNull.message = "Expected not to be null";</code></p>
          </div>
          <h3 data-title="+match(actual, pattern)+"
              id="<%= id('refute-match') %>"><code>refute.match(actual, pattern)</code></h3>
          <p>
            Fails in cases where <%= anchor("assert.match", "assert-match") %>
            passes.
          </p>
          <div class="msg">
            <h4>Messages</h4>
            <p><code>refute.match.exceptionMessage = "${0}";</code></p>
            <p>
              Used when the matcher function throws an exception. This happens
              if the matcher is not any of the accepted types, for instance, a
              boolean.
            </p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>
                Message from exception thrown by matcher function.
              </dd>
            </dl>
            <p><code>refute.match.message = "${0} expected not to match ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual objetc</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected object</dd>
            </dl>
          </div>
          <h3 data-title="+isObject(object)+" id="<%= id('refute-isObject') %>"><code>refute.isObject(object)</code></h3>
          <p>
            Fails if <code>object</code> is a non-null object.
          </p>
          <pre><code>refute.isObject({});             // Fails
refute.isObject(42);             // Passes
refute.isObject([1, 2, 3]);      // Fails
refute.isObject(function () {}); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.isObject.message = "${0} (${1}) expected not to be object and not null";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual object</dd>
              <dt><code>${1}</code></dt>
              <dd><code>typeof object</code></dd>
            </dl>
          </div>
          <h3 data-title="+isFunction(object)+" id="<%= id('refute-isFunction') %>"><code>refute.isFunction(actual)</code></h3>
          <p>
            Fails if <code>actual</code> is a function.
          </p>
          <pre><code>refute.isFunction({});             // Passes
refute.isFunction(42);             // Passes
refute.isFunction(function () {}); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.isFunction.message = "${0} (${1}) expected not to be function";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The actual value</dd>
              <dt><code>${1}</code></dt>
              <dd><code>typeof actual value</code></dd>
            </dl>
          </div>
          <h3 data-title="+exception(callback)+"
              id="<%= id('refute-exception') %>"><code>refute.exception(callback)</code></h3>
          <p>
            Fails if <code>callback</code> throws an exception.
          </p>
          <pre><code>refute.exception(function () {
    // Exercise code...
}); // Passes

refute.exception(function () {
    throw new TypeError("Ooops!");
}); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.exception.message = "Expected not to throw but threw ${0}, (${1})";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The type of exception thrown (if any)</dd>
              <dt><code>${1}</code></dt>
              <dd>The exception message</dd>
            </dl>
          </div>
          <h3 data-title="+tagName(element, tagName)+"
              id="<%= id('refute-tagName') %>"><code>refute.tagName(element, tagName)</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>tagName</code> property, or if its value <strong>is</strong> a
            case-insensitive match with the expected <code>tagName</code>.  The
            optional message is prepended to the failure message if provided.
          </p>
          <pre><code>refute.tagName(document.createElement("p"), "LI");  // Passes
refute.tagName(document.createElement("p"), "p");   // Fails
refute.tagName(document.createElement("h2"), "H3"); // Passes
refute.tagName(document.createElement("p"), "p");   // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.tagName.noTagNameMessage = "Expected ${1} to have tagName property";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The expected <code>tagName</code></dd>
              <dt><code>${1}</code></dt>
              <dd>
                If the object does not have a <code>tagName</code> property,
                this is the object.
              </dd>
            </dl>
          </div>
          <h3 data-title="+className(element, className)+"
              id="<%= id('refute-className') %>"><code>refute.className(element, className)</code></h3>
          <p>
            Fails if the <code>element</code> either does not specify
            a <code>className</code> property, or if its value <strong>is</strong>
            a space-separated list of all class names in <code>classNames</code>.
          </p>
          <p>
            <code>classNames</code> can be either a space-delimited string or an
            array of class names. If any class specified
            by <code>classNames</code> is not found in the object's
            <code>className</code> property the assertion passes. Order does not
            matter.
          </p>
          <pre><code>var el = document.createElement("p");
el.className = "feed item blog-post";

refute.className(el, "blog-post rss");  // Passes
refute.className(el, "feed item");      // Fails
refute.className(el, ["item", "feed"]); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.className.noClassNameMessage = "Expected object to have className property";</code></p>
            <p><code>refute.className.message = "Expected object's className to not include ${0} but was ${1}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The expected <code>classNames</code></dd>
              <dt><code>${1}</code></dt>
              <dd>
                The value of the object's <code>className</code> property, if
                any. Otherwise, the object itself.
              </dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('refute-stubs') %>">Stubs and spies</h2>
          <p>
            See <%= anchor("Stubs and spies", "stubs") %> for explanation. The
            following are spy/stub related refutations.
          </p>
          <h3 data-title="+called(spy)+"
              id="<%= id('refute-called') %>"><code>refute.called(spy)</code></h3>
          <p>
            Passes when spy has never been called.
          </p>
          <pre><code>var spy = sinon.spy();

refute.called(spy); // Passes

spy();
refute.called(spy); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.called.message = "Expected ${0} to not be called but was called ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls as a string. Ex: "two times".</dd>
              <dt><code>${2}</code></dt>
              <dd>All calls formatted as a multi-line string.</dd>
            </dl>
          </div>
          <h3 data-title="+callOrder(spy, spy2, ...)+"
              id="<%= id('refute-called') %>"><code>refute.callOrder(spy, spy2, ...)</code></h3>
          <p>
            Passes where
            <%= anchor "<code>assert.callOrder</code>", "assert-callOrder" %>
            fails.
          </p>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.callOrder.message = "Expected ${expected} not to be called in order";</code></p>
            <dl>
              <dt><code>${expected}</code></dt>
              <dd>A string representation of the expected call order</dd>
            </dl>
          </div>
          <h3 data-title="+calledOnce(spy)+"
              id="<%= id('refute-calledOnce') %>"><code>refute.calledOnce(spy)</code></h3>
          <p>
            Fails if the spy was called exactly once.
          </p>
          <pre><code>var spy = sinon.spy();

refute.called(spy); // Passes

spy();
refute.called(spy); // Fails

spy();
refute.called(spy); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.calledOnce.message = "Expected ${0} to not be called exactly once${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls, as a string. Ex: "two times"</dd>
              <dt><code>${2}</code></dt>
              <dd>
                The call log. All calls as a string. Each line is one call and
                includes passed arguments, returned value and more.
              </dd>
            </dl>
          </div>
          <h3 data-title="+calledTwice(spy)+"
              id="<%= id('refute-calledTwice') %>"><code>refute.calledTwice(spy)</code></h3>
          <p>
            Fails if the spy was called exactly twice.
          </p>
          <pre><code>var spy = sinon.spy();

refute.called(spy); // Passes

spy();
refute.called(spy); // Passes

spy();
refute.called(spy); // Fails

spy();
refute.called(spy); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.calledTwice.message = "Expected ${0} to not be called exactly twice${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls, as a string. Ex: "two times"</dd>
              <dt><code>${2}</code></dt>
              <dd>
                The call log. All calls as a string. Each line is one call and
                includes passed arguments, returned value and more.
              </dd>
            </dl>
          </div>
          <h3 data-title="+calledThrice(spy)+"
              id="<%= id('refute-calledThrice') %>"><code>refute.calledThrice(spy)</code></h3>
          <p>
            Fails if the spy was called exactly three times.
          </p>
          <pre><code>var spy = sinon.spy();
refute.called(spy); // Passes

spy();
refute.called(spy); // Passes

spy();
refute.called(spy); // Passes

spy();
refute.called(spy); // Fails

spy();
refute.called(spy); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.calledThrice.message = "Expected ${0} to not be called exactly thrice${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The number of calls, as a string. Ex: "two times"</dd>
              <dt><code>${2}</code></dt>
              <dd>
                The call log. All calls as a string. Each line is one call and
                includes passed arguments, returned value and more.
              </dd>
            </dl>
          </div>
          <h3 data-title="+calledWith(spy, arg1, arg2, ...)+"
              id="<%= id('refute-calledWith') %>"><code>refute.calledWith(spy, arg1, arg2, ...)</code></h3>
          <p>
            Fails if the spy was called at least once with the specified
            arguments.
          </p>
          <pre><code>var spy = sinon.spy();
var arr = [1, 2, 3];
spy(12);
spy(42, 13);
spy("Hey", arr, 2);

refute.calledWith(spy, 12);         // Fails
refute.calledWith(spy, "Hey");      // Fails
refute.calledWith(spy, "Hey", 12);  // Passes
refute.calledWith(spy, "Hey", arr); // Fails</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.calledWith.message = "Expected ${0} not to be called with arguments ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected arguments</dd>
              <dt><code>${2}</code></dt>
              <dd>String representation of all calls.</dd>
            </dl>
          </div>
          <h3 data-title="+calledOnceWith(spy, arg1, arg2, ...)+"
              id="<%= id('refute-calledOnceWith') %>"><code>refute.calledOnceWith(spy, arg1, arg2, ...)</code></h3>
          <p>
            Fails if the spy was called exactly once and with the specified
            arguments. Other arguments may have been passed after the specified
            ones.
          </p>
          <pre><code>var spy = sinon.spy();
var arr = [1, 2, 3];
spy(12);

refute.calledOnceWith(spy, 12);     // Fails
refute.calledOnceWith(spy, 42);     // Passes

spy(42, 13);
refute.calledOnceWith(spy, 42, 13); // Passes</code></pre>
          <div class="msg">
            <h4>Message</h4>
            <p><code>refute.calledOnceWith.message = "Expected ${0} not to be called once with arguments ${1}${2}";</code></p>
            <dl>
              <dt><code>${0}</code></dt>
              <dd>The spy</dd>
              <dt><code>${1}</code></dt>
              <dd>The expected arguments</dd>
              <dt><code>${2}</code></dt>
              <dd>String representation of all calls.</dd>
            </dl>
          </div>
        </div>
        <div class="section">
          <h2 id="<%= id('expectations') %>">Expectations</h2>
          <p>
            All of buster-assertion's assertions and refutations are also
            exposed as "expectations". Expectations is just a slightly different
            front-end to the same functionality, often preferred by the BDD
            inclined.
          </p>
          <p>
            Expectations mirror assertions under different names. Refutations
            can be expressed using <code>expect(obj).not()</code> and then
            calling either of the expectations on the resulting object.
          </p>
          <pre><code>var expect = buster.assertions.expect;

expect({ id: 42 }).toBeObject(); // Passes
expect("Somewhere in here").toMatch("in"); // Passes
expect(42).not().toEqual(43); // Passes</code></pre>
          <h3 data-title="+toBeSameAs(expected)+" id="<%= id('toBeSameAs') %>"><code>expect(actual).toBeSameAs(expected)</code></h3>
          <p>See <%=l "assert.same" %></p>
          <h3 data-title="+toEqual(expected)+" id="<%= id('toEqual') %>"><code>expect(actual).toEqual(expected)</code></h3>
          <p>See <%=l "assert.equals" %></p>
          <h3 data-title="+toBeType(type)+" id="<%= id('toBeType') %>"><code>expect(actual).toBeType(type)</code></h3>
          <p>See <%=l "assert.typeOf" %></p>
          <h3 data-title="+toBeDefined(expected)+" id="<%= id('toBeDefined') %>"><code>expect(actual).toBeDefined(expected)</code></h3>
          <p>See <%=l "assert.defined" %></p>
          <h3 data-title="+toBeNull(expected)+" id="<%= id('toBeNull') %>"><code>expect(actual).toBeNull(expected)</code></h3>
          <p>See <%=l "assert.isNull" %></p>
          <h3 data-title="+toMatch(expected)+" id="<%= id('toMatch') %>"><code>expect(actual).toMatch(expected)</code></h3>
          <p>See <%=l "assert.match" %></p>
          <h3 data-title="+toBeObject(expected)+" id="<%= id('toBeObject') %>"><code>expect(actual).toBeObject(expected)</code></h3>
          <p>See <%=l "assert.isObject" %></p>
          <h3 data-title="+toBeFunction(expected)+" id="<%= id('toBeFunction') %>"><code>expect(actual).toBeFunction(expected)</code></h3>
          <p>See <%=l "assert.isFunction" %></p>
          <h3 data-title="+toThrow(expected)+" id="<%= id('toThrow') %>"><code>expect(actual).toThrow(expected)</code></h3>
          <p>See <%=l "assert.exception" %></p>
          <h3 data-title="+toHaveTagName(expected)+" id="<%= id('toHaveTagName') %>"><code>expect(actual).toHaveTagName(expected)</code></h3>
          <p>See <%=l "assert.tagName" %></p>
          <h3 data-title="+toHaveClassName(expected)+" id="<%= id('toHaveClassName') %>"><code>expect(actual).toHaveClassName(expected)</code></h3>
          <p>See <%=l "assert.className" %></p>
          <h3 data-title="+toBeCalled()+" id="<%= id('toBeCalled') %>"><code>expect(spy).toBeCalled()</code></h3>
          <p>See <%=l "assert.called" %></p>
          <h3 data-title="+toBeCalledOnce()+" id="<%= id('toBeCalledOnce') %>"><code>expect(spy).toBeCalledOnce(expected)</code></h3>
          <p>See <%=l "assert.calledOnce" %></p>
          <h3 data-title="+toBeCalledTwice()+" id="<%= id('toBeCalledTwice') %>"><code>expect(spy).toBeCalledTwice(expected)</code></h3>
          <p>See <%=l "assert.calledTwice" %></p>
          <h3 data-title="+toBeCalledThrice()+" id="<%= id('toBeCalledThrice') %>"><code>expect(spy).toBeCalledThrice(expected)</code></h3>
          <p>See <%=l "assert.calledThrice" %></p>
          <h3 data-title="+toBeCalledWith(arg1, arg2, ...)+" id="<%= id('toBeCalledWith') %>"><code>expect(spy).toBeCalledWith(arg1, arg2, ...)</code></h3>
          <p>See <%=l "assert.calledWith" %></p>
          <h3 data-title="+toBeCalledOnceWith(arg1, arg2, ...)+" id="<%= id('toBeCalledOnceWith') %>"><code>expect(spy).toBeCalledOnceWith(arg1, arg2, ...)</code></h3>
          <p>See <%=l "assert.calledOnceWith" %></p>
        </div>
        <div class="section">
          <h2 id="<%= id('methods') %>">Methods</h2>
          <h3 id="<%= id('fail') %>"><code>fail(message)</code></h3>
          <p>
            When an assertion fails, it calls <code>buster.assertions.fail</code> with
            the failure message as the only argument. The built-in
            <code>fail</code> function both throws an <%=l "AssertionError" %> and
            emits it to the <%=e "failure" %> event. The error can be caught and
            handled by the test runner. If this behavior is not suitable for your
            testing framework of choice, you can override
            <code>buster.assertions.fail</code> to make it do the right thing.
          </p>
          <p>
            Example: To use <strong>buster-assertions</strong> with JsTestDriver, you
            can simply configure it as follows:
          </p>
          <pre><code>buster.assertions.fail = function (message) {
    fail(message);
};</code></pre>
          <p>
            Where the global <code>fail</code> function is the one provided by
            JsTestDriver.
          </p>
          <p>
            It is possible to make the default <code>assert.fail</code> method
            only emit an event and not throw an error. This may be suitable in
            asynchronous test runners, where you might not be able to catch
            exceptions. To silence exceptions, see the <%=l "throwOnFailure" %>
            property.
          </p>
          <h3 id="<%= id('format') %>"><code>format(object)</code></h3>
          <p>
            Values inserted into assertion messages using the <code>${n}</code>
            switches are formatted using <code>buster.assertions.format(obj)</code>.
            By default this method simply coerces the object to a string.
          </p>
          <p>
            A more expressive option is to use <%=m "format" %>, which is a
            generic function for formatting objects nicely as ascii. For nice
            ascii formatting of objects (including DOM elements) do:
          </p>
          <pre><code>buster.assertions.format = buster.format.ascii;</code></pre>
          <h3 id="<%= id('add') %>"><code>add(name, options)</code></h3>
          <p>
            Add a custom assertion. Using this 'macro' to add project specific
            assertions has a few advantages:
          </p>
          <ul>
            <li>Assertions will be counted.</li>
            <li>
              Failure messages will have interpolated arguments formatted by
              <%= anchor("<code>buster.assertions.format</code>", "format") %>.
            </li>
            <li>
              A single function generates both an assertion and a refutation.
            </li>
            <li>
              If using expectations, an expectation can easily be generated as
              well.
            </li>
            <li>
              When <%=l "failOnNoAssertions" %> is set to <code>true</code>, the
              assertion will behave correctly (may be important for asynchronous
              tests).
            </li>
            <li>The assertion will fail if too few arguments are passed.</li>
          </ul>
          <p>
            Here's an example of adding a "foo" assertion, that only passes when
            its only argument is the string "foo":
          </p>
          <pre><code>var assert = buster.assertions.assert;
var refute = buster.assertions.refute;
var expect = buster.assertions.expect;

buster.assertions.add("isFoo", {
    assert: function (actual) {
        return actual == "foo";
    },
    assertMessage: "Expected ${0} to be foo!",
    refuteMessage: "Expected not to be foo!",
    expect: "toBeFoo"
});

// Now you can do:
// Passes
assert.isFoo("foo");

// Fails: "[assert.isFoo] Expected { id: 42 } to be foo!"
assert.isFoo({ id: 42 });

// Fails: "[assert.isFoo] Ouch: Expected { id: 42 } to be foo!"
assert.isFoo({ id: 42 }, "Ouch");

// Fails: "[refute.isFoo] Expected not to be foo!"
refute.isFoo("foo");

// Passes
expect("foo").toBeFoo();</code>
            <h4>Error message value interpolation</h4>
            <p>
              Arguments are available in assertion failure messages using
              the <code>"${n}"</code> switches, where <code>n</code> is a
              number. You can also use named variables by setting properties
              on <code>this</code> in the assertion/refutation function:
            </p>
            <pre><code>buster.assertions.add("isString", {
    assert: function (actual) {
        this.actualType = typeof actual;
        return this.actualType == "string";
    },
    assertMessage: "Expected ${0} (${actualType}) to be string",
    refuteMessage: "Expected not to be string",
    expect: "toBeString"
});
</code></pre>
          <h4>Arguments</h4>
          <h5><code>name</code></h5>
          <p>The name of the new assertion/refutation.</p>
          <h5><code>options</code></h5>
          <dl class="properties">
            <dt><code>assert</code></dt>
            <dd>
              <p>
                The verification function. Should return <code>true</code> when
                the assertion passes. The generated refutation will pass when the
                function returns false.
              </p>
              <p>
                In some cases the refutation may not be the exact opposite of
                the assertion. If that is the case you should provide
                <code>options.refute</code> for the custom refutation.
              </p>
              <p>
                The number of formal parameters the function accepts determines
                the number of required arguments to the function. If the
                assertion is called with less arguments than expected, Buster
                will fail it before your custom function is even called.
              </p>
              <p>
                All arguments are available for interpolation into the resulting
                error message. The first argument will be available as
                <code>"${0}"</code>, the second as <code>"${1}"</code> and so
                on. If you want to embed other values than exact arguments into
                the string, you can set properties on <code>this</code> in the
                custom assertion, and refer to them as <code>"${name}"</code> in
                the message.
              </p>
            </dd>
            <dt><code>refute</code></dt>
            <dd>
              Custom refutation function. Used over <code>!assert()</code> if
              provided.
            </dd>
            <dt><code>assertMessage</code></dt>
            <dd>
              The error message to use when the assertion fails. The message may
              refer to arguments through switches like <code>"${0}"</code> and
              so on (see above, under the <code>assert</code> argument). The
              message is exposed on the generated assertion as the property
              <code>assert.[name].message</code>.
            </dd>
            <dt><code>refuteMessage</code></dt>
            <dd>
              Like <code>assertFail</code>, but for refutations. Exposed as
              <code>refute.[name].message</code>.
            </dd>
            <dt><code>values</code></dt>
            <dd>
              <p>
                A function that maps values to be interpolated into the failure
                messages. This can be used when you need something more/else than
                the actual arguments in order. For instance, the built-in
                <%= anchor("<code>assert.typeOf</code>", "assert-typeOf") %>
                assertion needs the actual type. Its <code>assertMessage</code> is
                <code>"Expected typeof ${0} (${2}) to be ${1}"</code>, and its
                <code>values</code> option is:
              </p>
              <pre><code>values: function (actual, expected) {
    return [actual, expected, typeof actual];
}</code></pre>
            </dd>
            <dt><code>expect</code></dt>
            <dd>
              The name of the assertion as an expectation,
              e.g. "toBeSomething". Optional.
            </dd>
          </dl>
          <h2 id="<%= id('utilities') %>">Supporting utilities</h2>
          <h3 id="<%= id('isNode') %>"><code>isNode(object)</code></h3>
          <p>
            Returns <code>true</code> if the object is a DOM node. The check is made by
            attempting to call <code>appendChild</code> on it, passing in an element.
          </p>
          <h3 id="<%= id('isElement') %>"><code>isElement(object)</code></h3>
          <p>
            Returns <code>true</code> if the object is a DOM element. The check is made
            by calling <%=anchor "buster.isNode", "isNode" %> and asserting that the
            element's <code>nodeType</code> is 1 (i.e. element).
          </p>
          <h3 id="<%= id('isArguments') %>"><code>isArguments(object)</code></h3>
          <p>
            Returns true if the argument is an <code>arguments</code> object. Buster
            checks this by making sure the object is array-like, but not actually an
            array.
          </p>
          <pre><code>function check() {
    buster.isArguments(arguments); // true
}

buster.isArguments([]); // false</code></pre>
          <h3 id="<%= id('keys') %>"><code>keys(object)</code></h3>
          <p>
            Cross-browser implementation of
            <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/keys">Object.keys</a>.
            From MDC: <q>returns an array whose elements are strings
            corresponding to the enumerable properties found directly upon
            object. The ordering of the properties is the same as that given by
            looping over the properties of the object manually</q>.
          </p>
        </div>
        <div class="section">
          <h2 id="<%= id('properties') %>">Properties</h2>
          <%= property("count", "0") %>
          <p>
            <code>buster.assertions.count</code> is incremented anytime an assertion
            is called. The assertion counter can be reset to any number at your
            convenience.
          </p>
          <%= property("throwOnFailure", "true") %>
          <p>
            When using the <%= anchor("default <code>fail</code>", "fail") %>
            implementation, this property can be set to <code>false</code> to make
            assertion failures <strong>not</strong> throw exceptions (i.e. only
            emit events). This may be suitable in asynchronous test runners, where
            you might not be able to catch exceptions.
          </p>
        </div>
        <div class="section">
          <h2 id="<%= id('supporting-objects') %>">Supporting objects</h2>
          <h3 id="<%= id('AssertionError') %>"><code>AssertionError</code></h3>
          <p>
            An exception (specifically, an <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error"><code>Error</code> object</a>) whose <code>name</code> property is <code>"AssertionError"</code>.
          </p>
        </div>
